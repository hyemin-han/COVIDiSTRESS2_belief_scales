current[,vaxs.1])
current$vax.attitude <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
# define items to be aligned
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
# function to estimate factor score with
# loadings (lambda.aligned) and intercepts (nu.aligned)
# through inverse matrix
aligned.factor.scores <- function(lambda,nu,y){
# calculate inverse matrix
lambda1 <- ginv((lambda))
# create matrix for nu
ns <- nrow(y)
nus <- matrix(nu,nrow=ns,ncol=length(nu),byrow=T)
# y - nu
y_nu <- y - nus
# f = inv(lambda)*(y-nu)
F <- lambda1 %*% t(as.matrix(y_nu))
}
# calculate score for each country
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
# aligned factor score
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.consp])
data.aligned$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.anti])
data.aligned$anti <- t(F)
}else
{
# bind
current <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
current[,variables.consp])
current$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
current[,variables.anti])
current$anti <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS)
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
# function to estimate factor score with
# loadings (lambda.aligned) and intercepts (nu.aligned)
# through inverse matrix
aligned.factor.scores <- function(lambda,nu,y){
# calculate inverse matrix
lambda1 <- ginv((lambda))
# create matrix for nu
ns <- nrow(y)
nus <- matrix(nu,nrow=ns,ncol=length(nu),byrow=T)
# y - nu
y_nu <- y - nus
# f = inv(lambda)*(y-nu)
F <- lambda1 %*% t(as.matrix(y_nu))
}
# calculate score for each country
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
# aligned factor score
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.consp])
data.aligned$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.anti])
data.aligned$anti <- t(F)
}else
{
# bind
current <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
current[,variables.consp])
current$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
current[,variables.anti])
current$anti <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
head(data.aligned)
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
# defined variables
variables.cor <- c('consp','anti','misperception_m','vaccine_midneutral',
'compliance_1','compliance_2','compliance_3','compliance_4',
'compliance_5','compliance_6','compliance_7')
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS,
BayesianFirstAid)
library(BayesianFirstAid)
install.packages('BayesianFirstAid')
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS,
psycho)
library(psycho)
library(BayesFactor)
correlationBF(dat_cor[,variables.cor[1]],dat_cor[,variables.cor[2]])
correlationBF(data.aligned[,variables.cor[1]],data.aligned[,variables.cor[2]])
test<-correlationBF(data.aligned[,variables.cor[1]],data.aligned[,variables.cor[2]])
test@bayesFactor
test@bayesFactor$bf
BFs <- matrix(nrow=length(variables.cor),ncol=length(variables.cor))
for (i in 1:length(variables.cor)){
for (j in (i+1):length(variables.cor)){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
BFs
i
j
# bayesian correlation
# BF matrix
BFs <- matrix(nrow=length(variables.cor)-1,ncol=length(variables.cor))
for (i in 1:length(variables.cor)){
for (j in (i+1):length(variables.cor)){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
BFs
colnames(BFs)<-variables.cor
BFs
rownames(BFs)<-variables.cor[1: length(variables.cor)-1]
BFs
knitr::opts_chunk$set(echo = TRUE)
# load libraries
if (!require("pacman")){
install.packages("pacman")
}
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS,
BayesFactor)
# set the current directory
here::i_am('README.md')
here::here()
#memory.limit(size=56000) #you might have to increase your memory limit
# load data
dat <- import(here("_cleandata/Final_COVIDiSTRESS_Vol2_cleaned.csv"))
# rename education levels
dat$education[dat$education == "University degree (e.g., MA, MSc, BA, BSc)"] <- "University degree"
dat$education[dat$education == "Some University or equivalent \r\n(still ongoing, or completed a module or more, but did not graduate)"] <- "Some University"
# load files
load(here('1_conspiracy/1_conspiracy.RData'))
load(here('2_antiexpert/2_antiexpert.Rdata'))
# extract variables of interest
dat_cor<- dat %>% dplyr::select(UserLanguage, #subset df
contains("antiexpert"),
contains("conspirational_think"),
contains("vaccine_midneutral"),
contains("compliance"),
contains('misperception'),
-contains("NAppl"))
# calc misperception mean
dat_cor$misperception_m <- with(dat_cor, rowMeans(dat %>% dplyr::select(
contains('misperception')
),na.rm=T))
# define items to be aligned
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
# function to estimate factor score with
# loadings (lambda.aligned) and intercepts (nu.aligned)
# through inverse matrix
aligned.factor.scores <- function(lambda,nu,y){
# calculate inverse matrix
lambda1 <- ginv((lambda))
# create matrix for nu
ns <- nrow(y)
nus <- matrix(nu,nrow=ns,ncol=length(nu),byrow=T)
# y - nu
y_nu <- y - nus
# f = inv(lambda)*(y-nu)
F <- lambda1 %*% t(as.matrix(y_nu))
}
# calculate score for each country
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
# aligned factor score
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.consp])
data.aligned$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.anti])
data.aligned$anti <- t(F)
}else
{
# bind
current <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
current[,variables.consp])
current$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
current[,variables.anti])
current$anti <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
# defined variables
variables.cor <- c('consp','anti','misperception_m','vaccine_midneutral',
'compliance_1','compliance_2','compliance_3','compliance_4',
'compliance_5','compliance_6','compliance_7')
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
# bayesian correlation
# BF matrix
BFs <- matrix(nrow=length(variables.cor)-1,ncol=length(variables.cor))
for (i in 1:length(variables.cor)){
for (j in (i+1):(length(variables.cor)-1)){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
knitr::opts_chunk$set(echo = TRUE)
# load libraries
if (!require("pacman")){
install.packages("pacman")
}
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS,
BayesFactor)
# set the current directory
here::i_am('README.md')
here::here()
#memory.limit(size=56000) #you might have to increase your memory limit
# load data
dat <- import(here("_cleandata/Final_COVIDiSTRESS_Vol2_cleaned.csv"))
# rename education levels
dat$education[dat$education == "University degree (e.g., MA, MSc, BA, BSc)"] <- "University degree"
dat$education[dat$education == "Some University or equivalent \r\n(still ongoing, or completed a module or more, but did not graduate)"] <- "Some University"
# load files
load(here('1_conspiracy/1_conspiracy.RData'))
load(here('2_antiexpert/2_antiexpert.Rdata'))
# extract variables of interest
dat_cor<- dat %>% dplyr::select(UserLanguage, #subset df
contains("antiexpert"),
contains("conspirational_think"),
contains("vaccine_midneutral"),
contains("compliance"),
contains('misperception'),
-contains("NAppl"))
# calc misperception mean
dat_cor$misperception_m <- with(dat_cor, rowMeans(dat %>% dplyr::select(
contains('misperception')
),na.rm=T))
# define items to be aligned
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
# function to estimate factor score with
# loadings (lambda.aligned) and intercepts (nu.aligned)
# through inverse matrix
aligned.factor.scores <- function(lambda,nu,y){
# calculate inverse matrix
lambda1 <- ginv((lambda))
# create matrix for nu
ns <- nrow(y)
nus <- matrix(nu,nrow=ns,ncol=length(nu),byrow=T)
# y - nu
y_nu <- y - nus
# f = inv(lambda)*(y-nu)
F <- lambda1 %*% t(as.matrix(y_nu))
}
# calculate score for each country
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
# aligned factor score
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.consp])
data.aligned$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.anti])
data.aligned$anti <- t(F)
}else
{
# bind
current <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
current[,variables.consp])
current$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
current[,variables.anti])
current$anti <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
# defined variables
variables.cor <- c('consp','anti','misperception_m','vaccine_midneutral',
'compliance_1','compliance_2','compliance_3','compliance_4',
'compliance_5','compliance_6','compliance_7')
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
# bayesian correlation
# BF matrix
BFs <- matrix(nrow=length(variables.cor),ncol=length(variables.cor))
for (i in 1:length(variables.cor)){
for (j in (i+1):(length(variables.cor)-1)){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
variables.cor <- c('consp','anti','misperception_m','vaccine_midneutral',
'compliance_1','compliance_2','compliance_3','compliance_4',
'compliance_5','compliance_6','compliance_7')
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
# bayesian correlation
# BF matrix
BFs <- matrix(nrow=length(variables.cor),ncol=length(variables.cor))
for (i in 1:length(variables.cor)){
for (j in (i+1):(length(variables.cor)-1)){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
colnames(BFs)<-variables.cor
rownames(BFs)<-variables.cor[1: length(variables.cor)-1]
i
j
variables.cor[i]
variables.cor[j]
length(variables.cor)
knitr::opts_chunk$set(echo = TRUE)
# load libraries
if (!require("pacman")){
install.packages("pacman")
}
pacman::p_load(tidyverse,
rio,
psych,
car,
lavaan,
sirt,
here,
MASS,
BayesFactor)
# set the current directory
here::i_am('README.md')
here::here()
#memory.limit(size=56000) #you might have to increase your memory limit
# load data
dat <- import(here("_cleandata/Final_COVIDiSTRESS_Vol2_cleaned.csv"))
# rename education levels
dat$education[dat$education == "University degree (e.g., MA, MSc, BA, BSc)"] <- "University degree"
dat$education[dat$education == "Some University or equivalent \r\n(still ongoing, or completed a module or more, but did not graduate)"] <- "Some University"
# load files
load(here('1_conspiracy/1_conspiracy.RData'))
load(here('2_antiexpert/2_antiexpert.Rdata'))
# extract variables of interest
dat_cor<- dat %>% dplyr::select(UserLanguage, #subset df
contains("antiexpert"),
contains("conspirational_think"),
contains("vaccine_midneutral"),
contains("compliance"),
contains('misperception'),
-contains("NAppl"))
# calc misperception mean
dat_cor$misperception_m <- with(dat_cor, rowMeans(dat %>% dplyr::select(
contains('misperception')
),na.rm=T))
# define items to be aligned
variables.consp <- c('conspirational_think_1','conspirational_think_2',
'conspirational_think_3','conspirational_think_4')
variables.anti <- c('antiexpert_1','antiexpert_2','antiexpert_3')
# function to estimate factor score with
# loadings (lambda.aligned) and intercepts (nu.aligned)
# through inverse matrix
aligned.factor.scores <- function(lambda,nu,y){
# calculate inverse matrix
lambda1 <- ginv((lambda))
# create matrix for nu
ns <- nrow(y)
nus <- matrix(nu,nrow=ns,ncol=length(nu),byrow=T)
# y - nu
y_nu <- y - nus
# f = inv(lambda)*(y-nu)
F <- lambda1 %*% t(as.matrix(y_nu))
}
# calculate score for each country
for (i in 1:length(langs.include)){
if (i == 1){
# create new matrix
data.aligned <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
# aligned factor score
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.consp])
data.aligned$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
dat_cor[dat_cor$UserLanguage==langs.include[i],variables.anti])
data.aligned$anti <- t(F)
}else
{
# bind
current <- dat_cor[dat_cor$UserLanguage==langs.include[i],]
F <- aligned.factor.scores(mod1$lambda.aligned[i,],
mod1$nu.aligned[i,],
current[,variables.consp])
current$consp <- t(F)
F <- aligned.factor.scores(mod2$lambda.aligned[i,],
mod2$nu.aligned[i,],
current[,variables.anti])
current$anti <- t(F)
data.aligned <- rbind(data.aligned,current)
}
}
# defined variables
variables.cor <- c('consp','anti','misperception_m','vaccine_midneutral',
'compliance_1','compliance_2','compliance_3','compliance_4',
'compliance_5','compliance_6','compliance_7')
# frequentist correlation
psych::corr.test(data.aligned[,variables.cor])
# bayesian correlation
# BF matrix
BFs <- matrix(nrow=length(variables.cor),ncol=length(variables.cor))
for (i in 1:(length(variables.cor)-1)){
for (j in (i+1):(length(variables.cor))){
# calculate BF
nowBF <- correlationBF(data.aligned[,variables.cor[i]],
data.aligned[,variables.cor[j]])
BFs[i,j] <- nowBF@bayesFactor$bf
}
}
colnames(BFs)<-variables.cor
rownames(BFs)<-variables.cor[1: length(variables.cor)-1]
i
j
rownames(BFs)
colnames(BFs)
BFs
variables.cor[1: length(variables.cor)-1]
rownames(BFs)<-variables.cor[1: length(variables.cor)]
BFs
